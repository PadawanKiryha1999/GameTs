{"ast":null,"code":"export default class MeleeStrategy {\n  doAlgorithm(atackingUnit, target, targets, battleField, HP) {\n    const copyHP = [...HP];\n    const _damage = battleField[atackingUnit]._damage;\n    console.log(\"atackingUnit\", atackingUnit);\n    console.log(\"targets\", targets);\n    battleField.forEach((unit, index) => {\n      if (targets.indexOf(unit._id) === -1) {} else {\n        console.log(\"do hp reduce\");\n        unit.doHPreduce(_damage);\n        if (_damage >= HP[target]) copyHP[target] = 0;else {\n          console.log(\"current HP\", HP[index]);\n          copyHP[target] = HP[target] - _damage;\n        }\n      }\n    });\n    console.log(\"its buttleField after deal damage\", battleField);\n    return copyHP;\n  }\n\n  doTargetSelection(unit, battleField) {\n    // const fun = (enemies: Array<Unit>, allies: Array<Unit>): Array<Unit> => {\n    //   console.log(\"enemies\", enemies);\n    //   console.log(\"allies\", allies);\n    //   const alliesFirstLane: Array<Unit> = allies.slice(0, 3);\n    //   const alliesSecondLane: Array<Unit> = allies.slice(3, 6);\n    //   const enemiesSecondLane: Array<Unit> = enemies.slice(0, 3);\n    //   const enemiesFirstLane: Array<Unit> = enemies.slice(3, 6);\n    //   console.log(\"enemies first lane\", enemiesFirstLane);\n    //   console.log(\"enemies second lane\", enemiesSecondLane);\n    //   console.log(\"allies first lane\", alliesFirstLane);\n    //   console.log(\"allis second lane\", alliesSecondLane);\n    //   loop0: for (let index = 0; index < 3; ++index) {\n    //     console.log(\"index first lane\", index);\n    //     if (alliesFirstLane[index]._id === unit._id) {\n    //       if (index === 1) {\n    //         console.log(\"in first lane center \");\n    //         enemies = enemiesFirstLane;\n    //         break;\n    //       } else if (index === 0) {\n    //         console.log(\"in first lane left \");\n    //         const copy: Array<Unit> = [...enemiesFirstLane];\n    //         copy.pop();\n    //         enemies = copy;\n    //         break;\n    //       } else {\n    //         console.log(\"in first lane right \");\n    //         const copy: Array<Unit> = [...enemiesFirstLane];\n    //         copy.shift();\n    //         enemies = copy;\n    //         break;\n    //       }\n    //     }\n    //   }\n    //   return enemies;\n    // };\n    if (unit._id > 5) {\n      // return fun(battleField.slice(0, 6), battleField.slice(6, 12));\n      let enemies = battleField.slice(0, 6);\n      const allies = battleField.slice(6, 12);\n      console.log(\"enemies\", enemies);\n      console.log(\"allies\", allies);\n      const alliesFirstLane = allies.slice(0, 3);\n      const alliesSecondLane = allies.slice(3, 6);\n      const enemiesSecondLane = enemies.slice(0, 3);\n      const enemiesFirstLane = enemies.slice(3, 6);\n      console.log(\"enemies first lane\", enemiesFirstLane);\n      console.log(\"enemies second lane\", enemiesSecondLane);\n      console.log(\"allies first lane\", alliesFirstLane);\n      console.log(\"allis second lane\", alliesSecondLane);\n      const isInFirstLane = false;\n\n      for (let index = 0; index < 3; index++) {\n        console.log(\"index first lane\", index);\n\n        if (alliesFirstLane[index]._id === unit._id) {\n          if (index === 1) {\n            console.log(\"in first lane center \");\n            const copy = [...enemiesFirstLane];\n            const targets = copy.filter(unit => unit._HP > 0);\n            enemies = targets;\n            break;\n          } else if (index === 0) {\n            console.log(\"in first lane left \");\n            const copy = [...enemiesFirstLane];\n            copy.pop();\n            const targets = copy.filter(unit => unit._HP > 0);\n            enemies = targets;\n            break;\n          } else {\n            console.log(\"in first lane right \");\n            const copy = [...enemiesFirstLane];\n            copy.shift();\n            const targets = copy.filter(unit => unit._HP > 0);\n            enemies = targets;\n            break;\n          }\n        }\n      }\n\n      for (let index = 0; index < 3; ++index) {\n        if (alliesSecondLane[index]._id === unit._id) {\n          enemies = [];\n        }\n      }\n\n      let deathUnit = 0;\n      alliesFirstLane.forEach(unit => {\n        if (unit._HP === 0) ++deathUnit;\n      });\n      console.log(\"умершие юниты\", deathUnit);\n      return enemies;\n    } else {\n      // return fun(battleField.slice(6, 12), battleField.slice(0, 6));\n      let enemies = battleField.slice(6, 12);\n      const allies = battleField.slice(0, 6);\n      console.log(\"enemies\", enemies);\n      console.log(\"allies\", allies);\n      const alliesSecondLane = allies.slice(0, 3);\n      const alliesFirstLane = allies.slice(3, 6);\n      const enemiesFirstLane = enemies.slice(0, 3);\n      const enemiesSecondLane = enemies.slice(3, 6);\n      console.log(\"enemies first lane\", enemiesFirstLane);\n      console.log(\"enemies second lane\", enemiesSecondLane);\n      console.log(\"allies first lane\", alliesFirstLane);\n      console.log(\"allis second lane\", alliesSecondLane);\n\n      for (let index = 0; index < 3; ++index) {\n        console.log(\"index first lane\", index);\n\n        if (alliesFirstLane[index]._id === unit._id) {\n          if (index === 1) {\n            console.log(\"in first lane center \");\n            enemies = enemiesFirstLane;\n            break;\n          } else if (index === 0) {\n            console.log(\"in first lane left \");\n            const copy = [...enemiesFirstLane];\n            copy.pop();\n            enemies = copy;\n            break;\n          } else {\n            console.log(\"in first lane right \");\n            const copy = [...enemiesFirstLane];\n            copy.shift();\n            enemies = copy;\n            break;\n          }\n        }\n      }\n\n      for (let index = 0; index < 3; ++index) {\n        if (alliesSecondLane[index]._id === unit._id) {\n          enemies = [];\n        }\n      }\n\n      let deathUnit = 0;\n      alliesFirstLane.forEach(unit => {\n        if (unit._HP === 0) ++deathUnit;\n      });\n      console.log(\"умершие юниты\", deathUnit);\n      return enemies;\n    }\n  }\n\n}","map":{"version":3,"sources":["/home/kirill/WorkFolder/GameTS/my-app/src/strategy/classes/unitStrategy/MeleeStrategy.ts"],"names":["MeleeStrategy","doAlgorithm","atackingUnit","target","targets","battleField","HP","copyHP","_damage","console","log","forEach","unit","index","indexOf","_id","doHPreduce","doTargetSelection","enemies","slice","allies","alliesFirstLane","alliesSecondLane","enemiesSecondLane","enemiesFirstLane","isInFirstLane","copy","filter","_HP","pop","shift","deathUnit"],"mappings":"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","sourcesContent":["import IStrategy from \"../../interface/IConcreteStrategy\";\nimport Unit from \"../unit/Unit\";\nexport default class MeleeStrategy implements IStrategy {\n  public doAlgorithm(\n    atackingUnit: number,\n    target: number,\n    targets: number[],\n    battleField: Array<Unit>,\n    HP: number[]\n  ): number[] {\n    const copyHP: number[] = [...HP];\n    const { _damage } = battleField[atackingUnit];\n    console.log(\"atackingUnit\", atackingUnit);\n    console.log(\"targets\", targets);\n    battleField.forEach((unit, index) => {\n      if (targets.indexOf(unit._id) === -1) {\n      } else {\n        console.log(\"do hp reduce\");\n        unit.doHPreduce(_damage);\n        if (_damage >= HP[target]) copyHP[target] = 0;\n        else {\n          console.log(\"current HP\",HP[index])\n          copyHP[target] = HP[target] - _damage;\n          \n        }\n      }\n    });\n\n    console.log(\"its buttleField after deal damage\", battleField);\n    return copyHP;\n  }\n  public doTargetSelection(unit: Unit, battleField: Array<Unit>): Array<Unit> {\n    // const fun = (enemies: Array<Unit>, allies: Array<Unit>): Array<Unit> => {\n    //   console.log(\"enemies\", enemies);\n    //   console.log(\"allies\", allies);\n    //   const alliesFirstLane: Array<Unit> = allies.slice(0, 3);\n    //   const alliesSecondLane: Array<Unit> = allies.slice(3, 6);\n    //   const enemiesSecondLane: Array<Unit> = enemies.slice(0, 3);\n    //   const enemiesFirstLane: Array<Unit> = enemies.slice(3, 6);\n    //   console.log(\"enemies first lane\", enemiesFirstLane);\n    //   console.log(\"enemies second lane\", enemiesSecondLane);\n    //   console.log(\"allies first lane\", alliesFirstLane);\n    //   console.log(\"allis second lane\", alliesSecondLane);\n\n    //   loop0: for (let index = 0; index < 3; ++index) {\n    //     console.log(\"index first lane\", index);\n    //     if (alliesFirstLane[index]._id === unit._id) {\n    //       if (index === 1) {\n    //         console.log(\"in first lane center \");\n    //         enemies = enemiesFirstLane;\n    //         break;\n    //       } else if (index === 0) {\n    //         console.log(\"in first lane left \");\n    //         const copy: Array<Unit> = [...enemiesFirstLane];\n    //         copy.pop();\n    //         enemies = copy;\n    //         break;\n    //       } else {\n    //         console.log(\"in first lane right \");\n    //         const copy: Array<Unit> = [...enemiesFirstLane];\n    //         copy.shift();\n    //         enemies = copy;\n    //         break;\n    //       }\n    //     }\n    //   }\n    //   return enemies;\n    // };\n    if (unit._id > 5) {\n      // return fun(battleField.slice(0, 6), battleField.slice(6, 12));\n      let enemies: Array<Unit> = battleField.slice(0, 6);\n      const allies: Array<Unit> = battleField.slice(6, 12);\n      console.log(\"enemies\", enemies);\n      console.log(\"allies\", allies);\n      const alliesFirstLane: Array<Unit> = allies.slice(0, 3);\n      const alliesSecondLane: Array<Unit> = allies.slice(3, 6);\n      const enemiesSecondLane: Array<Unit> = enemies.slice(0, 3);\n      const enemiesFirstLane: Array<Unit> = enemies.slice(3, 6);\n      console.log(\"enemies first lane\", enemiesFirstLane);\n      console.log(\"enemies second lane\", enemiesSecondLane);\n      console.log(\"allies first lane\", alliesFirstLane);\n      console.log(\"allis second lane\", alliesSecondLane);\n\n      const isInFirstLane = false;\n      for (let index = 0; index < 3; index++) {\n        console.log(\"index first lane\", index);\n        if (alliesFirstLane[index]._id === unit._id) {\n          if (index === 1) {\n            console.log(\"in first lane center \");\n            const copy: Array<Unit> = [...enemiesFirstLane];\n            const targets: Array<Unit> = copy.filter(unit => unit._HP > 0);\n            enemies = targets;\n            break;\n          } else if (index === 0) {\n            console.log(\"in first lane left \");\n            const copy: Array<Unit> = [...enemiesFirstLane];\n            copy.pop();\n            const targets: Array<Unit> = copy.filter(unit => unit._HP > 0);\n            enemies = targets;\n            break;\n          } else {\n            console.log(\"in first lane right \");\n            const copy: Array<Unit> = [...enemiesFirstLane];\n            copy.shift();\n            const targets: Array<Unit> = copy.filter(unit => unit._HP > 0);\n            enemies = targets;\n            break;\n          }\n        }\n      }\n      for (let index = 0; index < 3; ++index) {\n        if (alliesSecondLane[index]._id === unit._id) {\n          enemies = [];\n        }\n      }\n      let deathUnit: number = 0;\n      alliesFirstLane.forEach(unit => {\n        if (unit._HP === 0) ++deathUnit;\n      });\n      console.log(\"умершие юниты\", deathUnit);\n      return enemies;\n    } else {\n      // return fun(battleField.slice(6, 12), battleField.slice(0, 6));\n      let enemies: Array<Unit> = battleField.slice(6, 12);\n      const allies: Array<Unit> = battleField.slice(0, 6);\n      console.log(\"enemies\", enemies);\n      console.log(\"allies\", allies);\n      const alliesSecondLane: Array<Unit> = allies.slice(0, 3);\n      const alliesFirstLane: Array<Unit> = allies.slice(3, 6);\n      const enemiesFirstLane: Array<Unit> = enemies.slice(0, 3);\n      const enemiesSecondLane: Array<Unit> = enemies.slice(3, 6);\n      console.log(\"enemies first lane\", enemiesFirstLane);\n      console.log(\"enemies second lane\", enemiesSecondLane);\n      console.log(\"allies first lane\", alliesFirstLane);\n      console.log(\"allis second lane\", alliesSecondLane);\n\n      for (let index = 0; index < 3; ++index) {\n        console.log(\"index first lane\", index);\n        if (alliesFirstLane[index]._id === unit._id) {\n          if (index === 1) {\n            console.log(\"in first lane center \");\n            enemies = enemiesFirstLane;\n            break;\n          } else if (index === 0) {\n            console.log(\"in first lane left \");\n            const copy: Array<Unit> = [...enemiesFirstLane];\n            copy.pop();\n            enemies = copy;\n            break;\n          } else {\n            console.log(\"in first lane right \");\n            const copy: Array<Unit> = [...enemiesFirstLane];\n            copy.shift();\n            enemies = copy;\n            break;\n          }\n        }\n      }\n\n      for (let index = 0; index < 3; ++index) {\n        if (alliesSecondLane[index]._id === unit._id) {\n          enemies = [];\n        }\n      }\n\n      let deathUnit: number = 0;\n      alliesFirstLane.forEach(unit => {\n        if (unit._HP === 0) ++deathUnit;\n      });\n      console.log(\"умершие юниты\", deathUnit);\n      return enemies;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}