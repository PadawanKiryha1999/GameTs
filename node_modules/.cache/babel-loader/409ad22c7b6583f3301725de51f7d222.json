{"ast":null,"code":"export const generateQueue = (units, newTurn, isHexed) => {\n  let copy = Object.assign([], units);\n  const copyFilteredHP = [...copy];\n  const a = [];\n\n  if (newTurn) {\n    console.log(\"its new round\");\n\n    if (isHexed) {\n      console.log(\"is hexed from generate\");\n      const filteredHPFilterUnHex = copyFilteredHP.filter((unit, index) => isHexed[index] === false);\n      console.log(\"Отфильтровано по хп  и инициативе и хексу\", filteredHPFilterUnHex);\n    }\n\n    const filteredHP = copyFilteredHP.filter(unit => unit._HP > 0);\n    filteredHP.sort((a, b) => {\n      if (a._initiative < b._initiative) {\n        return 1;\n      }\n\n      if (a._initiative > b._initiative) {\n        return -1;\n      }\n\n      return 0;\n    });\n    console.log(\"Отфильтровано по хп  и инициативе\", filteredHP);\n    console.log(\"принеятый массив хексов\", isHexed);\n    return filteredHP;\n  }\n\n  copy.sort((a, b) => {\n    if (a._initiative < b._initiative) {\n      return 1;\n    }\n\n    if (a._initiative > b._initiative) {\n      return -1;\n    }\n\n    return 0;\n  });\n  return copy;\n};","map":{"version":3,"sources":["/home/kirill/WorkFolder/GameTS/my-app/src/Logic/Generatequeue.ts"],"names":["generateQueue","units","newTurn","isHexed","copy","Object","assign","copyFilteredHP","a","console","log","filteredHPFilterUnHex","filter","unit","index","filteredHP","_HP","sort","b","_initiative"],"mappings":"AACA,OAAO,MAAMA,aAAkB,GAAG,CAChCC,KADgC,EAEhCC,OAFgC,EAGhCC,OAHgC,KAI7B;AACH,MAAIC,IAAiB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,KAAlB,CAAxB;AACA,QAAMM,cAAc,GAAG,CAAC,GAAGH,IAAJ,CAAvB;AACA,QAAMI,CAAC,GAAG,EAAV;;AACA,MAAIN,OAAJ,EAAa;AACXO,IAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ;;AACA,QAAIP,OAAJ,EAAa;AACXM,MAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ;AAEA,YAAMC,qBAAkC,GAAGJ,cAAc,CAACK,MAAf,CACzC,CAACC,IAAD,EAAOC,KAAP,KAAiBX,OAAO,CAACW,KAAD,CAAP,KAAmB,KADK,CAA3C;AAGAL,MAAAA,OAAO,CAACC,GAAR,CACE,2CADF,EAEEC,qBAFF;AAID;;AACD,UAAMI,UAAuB,GAAGR,cAAc,CAACK,MAAf,CAAsBC,IAAI,IAAIA,IAAI,CAACG,GAAL,GAAW,CAAzC,CAAhC;AACAD,IAAAA,UAAU,CAACE,IAAX,CAAgB,CAACT,CAAD,EAAIU,CAAJ,KAAU;AACxB,UAAIV,CAAC,CAACW,WAAF,GAAgBD,CAAC,CAACC,WAAtB,EAAmC;AACjC,eAAO,CAAP;AACD;;AACD,UAAIX,CAAC,CAACW,WAAF,GAAgBD,CAAC,CAACC,WAAtB,EAAmC;AACjC,eAAO,CAAC,CAAR;AACD;;AACD,aAAO,CAAP;AACD,KARD;AASAV,IAAAA,OAAO,CAACC,GAAR,CAAY,mCAAZ,EAAiDK,UAAjD;AACAN,IAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAsCP,OAAtC;AACA,WAAOY,UAAP;AAED;;AAEDX,EAAAA,IAAI,CAACa,IAAL,CAAU,CAACT,CAAD,EAAIU,CAAJ,KAAU;AAClB,QAAIV,CAAC,CAACW,WAAF,GAAgBD,CAAC,CAACC,WAAtB,EAAmC;AACjC,aAAO,CAAP;AACD;;AACD,QAAIX,CAAC,CAACW,WAAF,GAAgBD,CAAC,CAACC,WAAtB,EAAmC;AACjC,aAAO,CAAC,CAAR;AACD;;AACD,WAAO,CAAP;AACD,GARD;AASA,SAAOf,IAAP;AACD,CA/CM","sourcesContent":["import Unit from \"../strategy/classes/unit/Unit\";\nexport const generateQueue: any = (\n  units: Array<Unit>,\n  newTurn?: string,\n  isHexed?: boolean[]\n) => {\n  let copy: Array<Unit> = Object.assign([], units);\n  const copyFilteredHP = [...copy];\n  const a = [];\n  if (newTurn) {\n    console.log(\"its new round\");\n    if (isHexed) {\n      console.log(\"is hexed from generate\");\n      \n      const filteredHPFilterUnHex: Array<Unit> = copyFilteredHP.filter(\n        (unit, index) => isHexed[index] === false\n      );\n      console.log(\n        \"Отфильтровано по хп  и инициативе и хексу\",\n        filteredHPFilterUnHex\n      );\n    }\n    const filteredHP: Array<Unit> = copyFilteredHP.filter(unit => unit._HP > 0);\n    filteredHP.sort((a, b) => {\n      if (a._initiative < b._initiative) {\n        return 1;\n      }\n      if (a._initiative > b._initiative) {\n        return -1;\n      }\n      return 0;\n    });\n    console.log(\"Отфильтровано по хп  и инициативе\", filteredHP);\n    console.log(\"принеятый массив хексов\",isHexed);\n    return filteredHP;\n    \n  }\n\n  copy.sort((a, b) => {\n    if (a._initiative < b._initiative) {\n      return 1;\n    }\n    if (a._initiative > b._initiative) {\n      return -1;\n    }\n    return 0;\n  });\n  return copy;\n};\n"]},"metadata":{},"sourceType":"module"}